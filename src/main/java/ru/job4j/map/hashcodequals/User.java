package ru.job4j.map.hashcodequals;

import java.util.*;

/**
 * 1. Создать модель User.
 * 2. Без переопределения equals и hashCode.
 * 3. Переопределить только hashCode.
 * 4. Переопределить только equals.
 * 5. Переопределить и equals, и hashCode.
 *
 * @author Constantine on 15.11.2021
 */
public class User {

    private String name;

    private int children;

    private Calendar birthday;

    public User(String name, int children, Calendar birthday) {
        this.name = name;
        this.children = children;
        this.birthday = birthday;
    }

    @Override
    public int hashCode() {
        int result = Objects.hashCode(name);
        result = 31 * result + Objects.hashCode(children);
        result = 31 * result + Objects.hashCode(birthday);
        return result;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        User user = (User) o;
        return children == user.children
                && Objects.equals(name, user.name)
                && Objects.equals(birthday, user.birthday);
    }

    /**
     * Если хеш-коды разные, то и входные объекты
     * ГАРАНТИРОВАННО разные!
     * Если хеш-коды равны, то входные объекты
     * НЕ ВСЕГДА РАВНЫ!
     *
     * ЕСЛИ НИЧЕГО НЕ ПЕРЕОПРЕДЕЛЕНО.
     *
     * 1.Рассмотрим исходный код метода {@code equals()}
     * в классе Object:
     *
     * public boolean equals(Object obj) {
     *         return (this == obj); }
     *
     * При сравнение объектов, операция “==” вернет true
     * лишь в одном случае — когда ссылки указывают на
     * один и тот-же объект. В данном случае не
     * учитывается содержимое полей.
     *
     * 2.Исходный код метода {@code hashCode()} в
     * классе {@link Object}:
     *
     * public native int hashCode();
     *
     *  Ключевое слово native означает, что реализация
     *  данного метода выполнена на другом языке.
     *  Конкретный native int hashCode() реализован на C++.
     *  При вычислении хэш-кода для объектов класса
     *  Object по умолчанию используется Park-Miller
     *  RNG алгоритм. В основу работы данного
     *  алгоритма положен генератор случайных чисел.
     *  Это означает, что при каждом запуске программы
     *  у объекта будет разный хэш-код.
     *
     * 3.После обработки хэш-кодов объекта внутренней
     * хэш-функцией таблицы для разных объектов с большой
     * долей вероятности будут назначены разные бакеты
     * (ячейки) для хранения (если разные объекты
     * регулярно попадают в один бакет - это значит,
     * что хэш-функция таблицы написана неоптимально).
     * Это означает, что не наступает факта коллизии
     * (коллизия - это факт помещения объекта в ранее
     * занятый другим объектом бакет), а это, в свою
     * очередь говорит о том, что не включается
     * механизм разрешения коллизий.
     *
     * 4.Теперь самое важное - метод equals() является частью
     * механизма разрешения коллизий, а если объекты в
     * разных бакетах - то механизм не включается -
     * equals() не вызывается.
     *
     * ЕСЛИ ПЕРЕОПРЕДЕЛЕН ТОЛЬКО HASHCODE().
     *
     * В данном случае после переопределения метода
     * {@code hashCode()} хэшкоды объектов становятся
     * одинаковыми. Во время добавления элемента в
     * карту происходит сравнение объектов по хэшкоду.
     * Далее происходит коллизия и включается механизм
     * разрешения коллизий, в котором сравниваем
     * добавляемый элемент с первым элементом
     * связного списка внутри бакета. Хеши ключей
     * одинаковые. Далее идет сравнение ключей по
     * ссылке. Так как ссылки на объекты User разные,
     * то ключи уже сравниваются посредством метода
     * {@code equals()}. Но так как equals()  не
     * переопределен, то сравнения не происходит
     * -> объекты будут разными. В итоге мы получим
     * связный список из 2 элементов в 1 бакете.
     *
     * 1.Объекты попали в один бакет.
     * 2.equals() вызывался, но использовалась
     * реализация по умолчанию - сравнение происходило
     * по ссылкам.
     *
     * ЕСЛИ ПЕРЕОПРЕДЕЛЕН ТОЛЬКО EQUALS().
     *
     * В данном случае после переопределения метода
     * {@code equals()} объекты будут одинаковыми.
     * Во время добавления элемента в карту происходит
     * сравнение объектов по хэшкоду. Так как метод
     * хэшкод использует реализацию нативную, то у
     * объектов будет разный хэш-код -> не наступает
     * факт коллизии -> не включается механизм
     * разрешения коллизий -> элементы всегда будут
     * находиться в разных бакетах. Выходит, что в
     * данном случае просто нет смысла в
     * переопределенном методе {@code equals()}.
     *
     * 1.Объекты попали в разные бакеты.
     * 2.equals() не вызывался, т.к. хешкоды
     * объектов всегда разные.
     *
     * ЕСЛИ ПЕРЕОПРЕДЕЛЕНЫ EQUALS() И HASHCODE().
     *
     * В данном случае после переопределения обоих
     * методов - {@code equals()} и {@code hashCode()}
     * хэшкоды объектов становятся одинаковыми и при
     * сравнении объектов по полям - они будут
     * одинаковыми (то есть это один и тот же объект).
     * Во время добавления элемента в карту происходит
     * сравнение объектов по хэшкоду. Далее происходит
     * коллизия и включается механизм разрешения
     * коллизий, в котором сравниваем добавляемый
     * элемент с первым элементом связного списка
     * внутри бакета. Хеши ключей одинаковые. Далее
     * идет сравнение ключей по ссылке. Так как ссылки
     * на объекты User разные, то ключи уже
     * сравниваются посредством метода equals().
     * В нашем случае equals() теперь также
     * переопределен - сравнение происходит по полям
     * объекта. Так как в нашем примере объекты
     * имеют одинаковые поля -> user1.equals(user2) = true.
     * А значит, что фактически эти 2 объекта -
     * это один и тот же объект.
     *
     * В результате происходит перезапись объекта
     * в тот же самый бакет.
     */
    public static void main(String[] args) {
        /*User first = new User("Consta", 0, new GregorianCalendar(1995, Calendar.MARCH, 6));
        User second = new User("Consta", 0, new GregorianCalendar(1995, Calendar.MARCH, 6));
        Map<User, Object> map = new HashMap<>();
        map.put(first, new Object());
        map.put(second, new Object());
        for (Map.Entry<User, Object> entry : map.entrySet()) {
            System.out.println(entry.getKey().hashCode() + " <- key : value -> " + entry.getValue());
        }
        System.out.println("Вызов метода equals()  - " + first.equals(second));*/
        System.out.println("Делаем свою мапу - этот код закрываю.");
    }
}
